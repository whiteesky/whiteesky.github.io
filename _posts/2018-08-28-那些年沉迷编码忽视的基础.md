---
layout: post
title: 【精】那些年沉迷编码忽视的基础
categories: 技术总结
author: whiteesky
date: 2018-08-28 20:52:46
tags:
  - 数据结构
  - Java
  - 设计模式
header-img: img/article/basic/header.jpg
copyright: true
---
本文发表于：**宜信大数据创新中心**
![1]

---

### 序

很多计科专业出身的朋友们都有过这样的想法：感觉很多专业课的学习都无足轻重。尤其在大学之初就被编程吸引住的同学们，就会更加沉迷于编码本身，而忽视其它专业基础课的学习。即便在之后自己实现了一些小的系统，也只是对数据库等知识比较关注而已。而像《计算机组成原理》、《编译原理》等课程通常是被大家忽略的，认为不做底层为何要学计原，不自己开发语言为何要懂编译。诚然，在校学习的过程中，我们可能真的感觉不到那些知识的应用性，最关注的还是语言本身的使用，但其它的知识真的无用武之地吗？

### 一分钱引发的惨案

在日常业务中，尤其是金融业务，经常会遇到金钱方面的计算。于是便引发了浮点数计算的精度问题。

很多老司机都在这个问题上坑过，其中不乏看过 **Effective Java** 但还是毅然跳坑的人：
> 如果需要精确的答案，请避免使用 float 和 double

即便如此，当计算金钱需要“元”转“分”时，很多人还是会下意识认为，乘个100这么整的数，怎么会有精度问题。但实际上：

> console.log(2.32*100) <br/>
> // 运行结果：231.99999999999997

车翻的就是这么猝不及防，前后端集体翻车也是见过的（逃）。

**《计算机组成原理》**中讲述了数据的机器层次表示。十进制小数向二进制小数的转换方式：**乘2取整**。因此，有如下转换（下标表示进制）：
> 0.5<sub>(10)</sub> -> 0.1<sub>(2)</sub> <br/>
> 0.25<sub>(10)</sub> -> 0.01<sub>(2)</sub>

那么0.2如何表示呢？
> 0.2<sub>(10)</sub> -> 0.00110011......<sub>(2)</sub>

显然，0.2转换为2进制是一个无限循环小数。而在计算机中，每个数字存储的位数都是有限的，那0.2必然不能被精确地表示。

当然，上述只给出了表面上的一个简单解释。真正的原理还请参照**《计算机组成原理》**中讲述的**IEEE754<sup>[1]</sup>**标准。如果能够真的理解清楚浮点数表示不精确的原因，就不会犯这种错误了。

### 排序思想的运用

**《数据结构与算法》**应该能算是大家能比较重视的基础了，但还是有些人抱有疑问。比如面试总会问到快排之类的算法，但好像工作中根本不会真的去写排序啊，各种库已经实现了很好用的排序算法了。

那假如有这样的需求：
> 统计用户每周使用APP的分钟数作为积分，给出排名。每周结束时给使用时长靠前的用户发奖励。日活百万。

一般来说我们会把整体排名放在cache里，但上述需求在每次排名变动时都需要对百万级数据直接排序，效率太低。而这个问题关键点在于排行榜分数是固定的，就是每周的分钟数，最大只有10080，远小于用户量。

是不是有一种排序的思想很适合？没错就是**桶式排序<sup>[2]</sup>**。

我们将对应分数个连续的桶放在Cache里，每个桶记录当前这个分数有多少个人。每当排名出现变化，就把原来分数的桶减1，新的桶加1，时间复杂度O(1)。用户查询自己的排名时，只要把比用户当前分数靠前的桶的数值累加即可。时间复杂度为O(n)。（n是桶数量而不是用户数量）

可以看到数量固定的情况下，很适合使用桶式的数据结构，并且在出现变化时，重排序效率很高。思想很简单，就看能不能在对应的情况下想到并合理地运用。

### 复杂的状态转换

在业务开发中，有时会遇到很多状态间的转换。状态本身会因为发生不同的操作而变化到另外一种状态。比如我们业务中会对用户群类型进行划分，通过用户不同的行为，会将其会转换到另一种类型。并且转换规则也会随业务经常调整。

很多人写代码时就会在对应的各代码逻辑处直接通过大量的判断逻辑进行处理，逻辑混乱且不容易维护，状态本身或状态间转换经常变化时更甚。

如果你认真学习过**《形式语言与自动机》**，那应该已经想到，这种情况类似一个**DFA（确定性有限状态自动机）<sup>[3]</sup>**。如果你曾经思考过一个简单自动机的实现方式，上述问题就很简单了。

下图是一个将业务中状态的转换写成DFA的例子：

![2]

定义如下：
> 状态集 Q = { S1, S2, S3, S4, S5, S6 } （用户状态） <br/>
> 输入字母表 Σ = { 0, 1, 2, 3, 4} （用户行为事件） <br/>
> 开始状态 s = S1 <br/>
> 接受状态集 F = { S6 } <br/>
> 转移函数： δ { S1, 0 } = S2，δ { S2, 4 } = S6，……  （状态转换规则）

通过以上定义，很容易就能通过代码抽象出一个DFA了。状态通过输入事件 Σ 来进行驱动，调用DFA对应的转移函数 δ 来进行状态转移。各部分的代码只需要负责将对应的事件传入DFA，完全不需要关心任何的状态转换逻辑。修改状态和转换规则时只需调整DFA的代码即可，代码非常清晰易维护。尤其针对现在流行的微服务架构，更是避免了因调整规则需要修改多个服务的问题。

### 逻辑运算的妙用

**《离散数学》**里学过一种很奇妙的逻辑运算符，就是**异或**运算。
异或运算的性质：
> 交换律：A ⊕ B = B ⊕ A <br/>
> 结合律：A ⊕ ( B ⊕ C ) = ( A ⊕ B ) ⊕ C <br/>
> 自反律：X ⊕ 0 = X <br/>
> 归零律：X ⊕ X = 0 <br/>

通过上述性质，可以推导出一条非常非常好用的结论：
> A ⊕ B ⊕ B = A ⊕ 0 = A

可能很多人对它的印象只是停留在一个经典的算法题目上：一组数据中只有一个数字出现一次，其他数成对出现，找出这个数。此题便可利用上述结论轻松解决。

这个结论在实际开发中也可以做很多事情，下面是一个我印象很深的用法：Storm的**ACKER**机制**<sup>[4]</sup>**。因为Storm的拓扑结构**<sup>[5]</sup>**很复杂，Spout发出的一个消息经过了很多Bolt处理，ACKER怎样去向Spout确认某条消息处理完成是件不容易的事情。

但是，某位大佬深刻理解了异或运算，于是设计出了以下的这套ACKER机制：

![3]

每个节点在向下个节点发送消息时，都会随着发出一个唯一的id。并且会将当前节点发出的id和接收到的上个节点的id一并发给ACKER。ACKER将会接收到一系列id，并对其进行异或操作。如果所有节点都成功处理了消息，那么ACKER接到的各个id都将有且仅有2个（因为每个id都会被发送者和接收者各发送一次）。最终通过异或的这条性质：A ⊕ B ⊕ B = A ⊕ 0 = A，一旦最后异或的结果为0，ACKER就可以直接发送ACK给到Spout了。

就这样，本来一个很复杂的问题，就被一个异或运算直接搞定了。

### 结语

笔者曾经在本科时也忽略了很多基础的学习，也是在之后才慢慢意识到了这些方面的不足，并逐渐加以补充。仅仅本科阶段我们就能学习到：《操作系统》、《计算机网络》、《数据库原理》、《计算机组成原理》、《数据结构与算法》、《离散数学》、《形式语言与自动机》、《编译原理》、《人工智能》、《软件工程》等等专业课程。但我想当时真正能够完全认真学进去的人恐怕不多。

计算机的理论基础其实就是工程师内功的修炼。知识其实也未必样样精通，但在思想上还是要有一定的了解。上述案例只是在编码过程中的一些简单应用，平时工程开发中会遇到各式各样的需求和场景，如果你的计算机功底够强，好的思路自然会涌现出来，就能写出真正高质高效且优雅的代码。

（完）

---

**[1]IEEE754**：全称为IEEE二进制浮点数算术标准，是业界的通用标准，规定了浮点数的表示方法和算数标准等。 <br/>
**[2] 桶排序**：已知数据的范围，创建对应连续N个桶，将待排数据分到各个对应的桶中，最后扫描桶来实现排序。 <br/>
**[3] DFA（确定性有限状态自动机）**：是一个能实现状态转移的自动机。对于一个给定的属于该自动机的状态和一个属于该自动机字母表的字符，它都能根据事先给定的转移函数转移到下一个状态。 <br/>
**[4] Storm的ACKER机制**： Storm消息可靠性通过ACKER实现。它负责跟踪每个Spout发出的消息是否被后面的各节点成功处理，并通知Spout。 <br/>
**[5] Storm的拓扑结构**： Storm提交运行的程序就是一个拓扑（Topology）。Topology由Spout和Bolt构成。Spout从数据源接收消息，将消息传递给Bolt；Bolt进行逻辑处理，可以随意订阅某个Spout或者Bolt的消息。



[1]: /img/article/basic/wechat.jpeg
[2]: /img/article/basic/automata.png
[3]: /img/article/basic/storm_acker.png
