---
layout: post
title: 利用Redis实现分布式锁功能
categories: 技术总结
author: whiteesky
date: 2018-01-24 20:43:09
tags:
  - Redis
  - Java
  - Lock
  - Distributed
header-img: img/article/distributed_lock/header.jpg
copyright: true
---
在日常的业务场景中，经常会遇到并发环境下多个请求访问同一个资源的问题。现在的服务大多都是部署在多台服务器上的，已经不能使用传统的锁方式进行加锁了。这个时候就需要构造一把分布式环境的锁来解决问题。

实现分布式锁有很多方式，本文介绍的是使用Redis构造分布式锁的方式。

加锁方式
---
在加锁时，我们可以采用setnx的操作，该命令会在key不存在的时候，将 key 的值设为 value，并返回成功或失败。我们可以将这个操作视为对key加锁，操作返回成功即加锁成功。

由于Redis是单线程模式，所以可以保证并发的请求只有一个能够成功调用setnx成功，获取到锁。得到锁的线程在处理逻辑后再将此key删除释放掉锁。

但是服务有可能在删除锁之前挂掉，所以为了避免死锁，需要利用expire命令对锁设置一个过期时间。
不过由于setnx和expire是两个操作，所以依然存在两个操作中间中断导致死锁的情况。

有些人可能不知道，在 Redis 2.6.12 版本之后，set命令已经进行了一定的升级：
```
SET key value [EX seconds] [PX milliseconds] [NX|XX]
```
- EX/PX：设置键的过期时间为 second 秒/millisecond 毫秒。
- NX ：只在键不存在时，才对键进行设置操作。
- XX ：只在键已经存在时，才对键进行设置操作。

当使用NX和XX命令时，如果成功设置了键，会返回OK；如果不成功，则返回nil。
显然，使用set命令可以完全代替setnx+expire的操作，并且还保证操作的原子性。


解锁方式
---
在解锁时，需要先检查锁是否是自己的线程所加的，否则有可能误删掉锁。比如，线程1加了锁，但是在执行完之前，锁就到时间了，此时线程2也加了锁。这时线程1刚好跑完，执行解锁，就会直接把线程2的锁删掉。

所以，在加锁进行set操作时我们需要生成一个唯一的值作为value保存，并通过一个ThreadLocal对象来记录当前线程的这个唯一值。该线程解锁时再读出并进行检查，保证解的锁确实是自己的。

但是，检查该唯一值和删除锁是两个操作，依然会出现并发的问题，所以在解锁时我们需要采用另一种原子性的操作。

从 Redis 2.6.0 版本开始，通过内置的 Lua 解释器，可以使用EVAL命令对Lua脚本进行求值。执行的时候会将Lua脚本视为一个命令进行处理：
```
EVAL script numkeys key [key ...] arg [arg ...]
```

我们传入以下简单的Lua脚本即可进行解锁：
```lua
if redis.call('get', KEYS[1]) == ARGV[1] then
    return redis.call('del', KEYS[1])
else
    return 0
end
```

其中，KEYS[1]传入锁的key，ARGV[1]传入锁的value。
这样我们同样通过一句指令，就完成了解锁的操作。

RedisTemplate的问题
---
由于我们现在基于Spring框架的开发经常会用到RedisTemplate进行Redis的相关操作，但是RedisTemplate并没有上述相关命令的封装。但是我们如果用原生Jedis去再做一个连接显然不是一个好的方式。

但实际上，我们可以通过如下方式，直接拿到RedisTemplate内部封装的的原生的Jedis连接去进行操作的：
```java
String result = redisTemplate.execute((RedisCallback<String>) connection -> {
    JedisCommands commands = (JedisCommands) connection.getNativeConnection();
    return commands.set(key, value, "NX", "PX", expireTimeMills);
});
```
